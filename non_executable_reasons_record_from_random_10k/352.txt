3.6
An error occurred while executing the following cell:
------------------
import warnings
warnings.filterwarnings('ignore')
from HelmholtzSolver2D import *
from ExampleBoundaries import Square

# Test Problem 1
# Dirichlet boundary condition with phi chose to be the same
# as a point-source at the center of the square.
#
solver = ExteriorHelmholtzSolver2D(Square())

frequency = 400.0 # frequency [Hz]
k = frequencyToWavenumber(frequency)

centerSquare = np.array([0.05, 0.05], dtype=np.float32)
boundaryCondition = solver.dirichletBoundaryCondition()
aCenter = solver.oGeometry.centers()
for i in range(aCenter.shape[0]):
    r = norm(aCenter[i, :] - centerSquare)
    boundaryCondition.f[i] = 1j * hankel1(0, k*r) / 4.0

boundaryIncidence = BoundaryIncidence(solver.numberOfElements())
boundaryIncidence.phi.fill(0.0)
boundaryIncidence.v.fill(0.0)

exteriorPoints = np.array([[0.0000,  0.1500],
                           [0.0500,  0.1500],
                           [0.1000,  0.1500],
                           [0.0500, -0.1000]], dtype=np.float32)

exteriorIncidentPhi = np.zeros(exteriorPoints.shape[0], dtype=np.complex64)

boundarySolution = solver.solveBoundary(k, boundaryCondition, boundaryIncidence)
sampleSolution = boundarySolution.solveSamples(exteriorIncidentPhi, exteriorPoints)
print("\n\nTest Problem 1")
print("==============\n")
print(boundarySolution)
print(sampleSolution)

# Test Problem 2
# Neumann boundary condition with v chosen to be the same
# as a point-source at the center of the square.
#
boundaryCondition = solver.neumannBoundaryCondition()

centerSquare = np.array([0.05, 0.05], dtype=np.float32)
for i in range(aCenter.shape[0]):
    x = aCenter[i, :]
    r = x - centerSquare
    R = norm(r)
    if x[0] <= 1e-7:
        drbdn = -r[0]/R
    elif x[0] >= 0.1 - 1e-7:
        drbdn = r[0]/R
    elif x[1] <= 1e-7:
        drbdn = -r[1]/R
    elif x[1] >= 0.1 - 1e-7:
        drbdn = r[1]/R
    else:
        assert False, "r = ({}, {}) not properly handled.".format(r[0], r[1])
    boundaryCondition.f[i] = -1j * k * drbdn * hankel1(1, k*R) / 4.0

boundarySolution = solver.solveBoundary(k, boundaryCondition, boundaryIncidence)
sampleSolution = boundarySolution.solveSamples(exteriorIncidentPhi, exteriorPoints)
print("\n\nTest Problem 2")
print("==============\n")
print(boundarySolution)
print(sampleSolution)

# Test Problem 3
# Neumann boundary condition with v=0 on the full boundary.
# The 400Hz field in this case is generated by a point source
# at (0.5, 0.25)
boundaryCondition = solver.neumannBoundaryCondition()

sourcePoint = np.array([0.5, 0.25], dtype=np.float32)
print("sourcePoint = ", sourcePoint)
for i in range(aCenter.shape[0]):
    x = aCenter[i, :]
    r = x - sourcePoint
    R = norm(r)
    boundaryIncidence.phi[i] = 1j * hankel1(0, k*R) / 4.0
    if x[0] <= 1e-7:
        drbdn = -r[0]/R
    elif x[0] >= 0.1 - 1e-7:
        drbdn = r[0]/R
    elif x[1] <= 1e-7:
        drbdn = -r[1]/R
    elif x[1] >= 0.1 - 1e-7:
        drbdn = r[1]/R
    else:
        assert False, "r = ({}, {}) not properly handled.".format(r[0], r[1])
    boundaryIncidence.v[i] = -1j * k * drbdn * hankel1(1, k*R) / 4.0

boundarySolution = solver.solveBoundary(k, boundaryCondition, boundaryIncidence)

for i in range(exteriorPoints.shape[0]):
    R = norm(exteriorPoints[i, :] - sourcePoint)
    exteriorIncidentPhi[i] = 1j * hankel1(0, k*R) / 4.0
    
sampleSolution = boundarySolution.solveSamples(exteriorIncidentPhi, exteriorPoints)
print("\n\nTest Problem 3")
print("==============\n")
print(boundarySolution)
print(sampleSolution)
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mModuleNotFoundError[0m                       Traceback (most recent call last)
[0;32m<ipython-input-1-9202f5acf6bf>[0m in [0;36m<module>[0;34m[0m
[1;32m      1[0m [0;32mimport[0m [0mwarnings[0m[0;34m[0m[0;34m[0m[0m
[1;32m      2[0m [0mwarnings[0m[0;34m.[0m[0mfilterwarnings[0m[0;34m([0m[0;34m'ignore'[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[0;32m----> 3[0;31m [0;32mfrom[0m [0mHelmholtzSolver2D[0m [0;32mimport[0m [0;34m*[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m      4[0m [0;32mfrom[0m [0mExampleBoundaries[0m [0;32mimport[0m [0mSquare[0m[0;34m[0m[0;34m[0m[0m
[1;32m      5[0m [0;34m[0m[0m

[0;31mModuleNotFoundError[0m: No module named 'HelmholtzSolver2D'
ModuleNotFoundError: No module named 'HelmholtzSolver2D'

Executability                            : False
